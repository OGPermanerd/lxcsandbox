---
phase: 03-stack-provisioning
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - 03-provision-container.sh
autonomous: true

must_haves:
  truths:
    - "Container is connected to Tailscale with 100.x.x.x IP"
    - "Node.js 22 is installed and nvm manages versions"
    - "npm, yarn, and pnpm are all available"
    - "PostgreSQL is running with dev/dev credentials accessible from anywhere"
    - "Playwright browsers (Chromium, Firefox) are installed"
    - "Claude Code CLI is installed and in PATH"
    - "Shell environment has database vars and useful aliases"
  artifacts:
    - path: "03-provision-container.sh"
      provides: "Complete provisioning script for dev stack"
      min_lines: 400
  key_links:
    - from: "03-provision-container.sh"
      to: "lxc exec"
      via: "Container command execution"
      pattern: "lxc exec.*bash -c"
    - from: "03-provision-container.sh"
      to: "Tailscale auth"
      via: "Auth key authentication"
      pattern: "tailscale up --authkey"
    - from: "03-provision-container.sh"
      to: "PostgreSQL config"
      via: "Remote access configuration"
      pattern: "listen_addresses.*\\*"
---

<objective>
Create the provisioning script (03-provision-container.sh) that installs a complete development stack inside LXC containers and connects them to Tailscale for direct IP access.

Purpose: Enable containers to be fully functional dev environments accessible via Tailscale IP with all tools (Node.js, PostgreSQL, Playwright, Claude Code) ready to use

Output: Single executable script `03-provision-container.sh` that provisions any container created by 02-create-container.sh
</objective>

<execution_context>
@/home/claude/.claude/get-shit-done/workflows/execute-plan.md
@/home/claude/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-stack-provisioning/03-CONTEXT.md
@.planning/phases/03-stack-provisioning/03-RESEARCH.md

Reference scripts for patterns:
@01-setup-host.sh (colors, logging, error handling, verification)
@02-create-container.sh (lxc exec, spinners, apt lock wait)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create provisioning script structure with argument handling and helper functions</name>
  <files>03-provision-container.sh</files>
  <action>
Create `03-provision-container.sh` with initial structure following patterns from 01/02 scripts.

**Script header:**
```bash
#!/bin/bash
#
# 03-provision-container.sh
# Installs complete dev stack in LXC container and connects to Tailscale
# Run as root or with sudo
#
# Usage: ./03-provision-container.sh <container-name> <tailscale-authkey>
# Example: ./03-provision-container.sh relay-dev tskey-auth-xxxxxxxx
```

**Standard setup:**
- `set -euo pipefail`
- ERR trap with line number
- Colors (RED, GREEN, YELLOW, NC)
- Logging functions (log_info, log_warn, log_error)
- Header banner "Dev Sandbox - Stack Provisioning"

**Argument handling:**
- Require exactly 2 arguments (container name, tailscale authkey)
- Validate container exists: `lxc info "$CONTAINER_NAME" &>/dev/null`
- Validate authkey format: starts with "tskey-" (basic sanity check)
- Show usage on error with example

**Root check:**
- Run after argument validation (better UX for name errors)

**Container execution helper:**
Create `container_exec()` function that wraps `lxc exec`:
```bash
container_exec() {
    lxc exec "$CONTAINER_NAME" -- bash -c "$1"
}
```

**Apt lock wait helper:**
Create function to wait for apt lock (copy pattern from 02 script):
```bash
wait_for_apt_lock() {
    container_exec '
        while fuser /var/lib/dpkg/lock-frontend >/dev/null 2>&1; do
            sleep 1
        done
    '
}
```

**Progress spinner helper:**
Create `run_with_spinner()` for long-running operations:
```bash
run_with_spinner() {
    local msg="$1"
    local cmd="$2"
    local spinstr='|/-\'
    local delay=0.1

    echo -n "  $msg..."
    # Run command in background, capture PID
    eval "$cmd" &>/dev/null &
    local pid=$!

    while kill -0 $pid 2>/dev/null; do
        local temp=${spinstr#?}
        printf "\r  [%c] %s" "$spinstr" "$msg"
        spinstr=$temp${spinstr%"$temp"}
        sleep $delay
    done

    wait $pid
    local status=$?
    printf "\r\033[K"  # Clear line

    if [[ $status -eq 0 ]]; then
        log_info "$msg - done"
    else
        log_error "$msg - failed"
        return $status
    fi
}
```

Variables to set at top:
- `CONTAINER_NAME="$1"`
- `TAILSCALE_AUTHKEY="$2"`
- `NVM_VERSION="v0.40.4"`
- `NODE_VERSION="22"`
- `PG_USER="dev"`
- `PG_PASS="dev"`
- `PG_DB="dev"`
  </action>
  <verify>Script is syntactically valid: `bash -n 03-provision-container.sh`</verify>
  <done>Script has proper header, argument handling, helper functions, and passes syntax check</done>
</task>

<task type="auto">
  <name>Task 2: Implement Tailscale installation and connection (PROV-02, PROV-03, PROV-04)</name>
  <files>03-provision-container.sh</files>
  <action>
Add Tailscale installation function after helper functions.

**Idempotency check:**
```bash
install_tailscale() {
    log_info "Setting up Tailscale..."

    # Check if already installed and connected
    if container_exec 'command -v tailscale &>/dev/null'; then
        if container_exec 'tailscale status 2>/dev/null | grep -q "^100\\."'; then
            local ts_ip
            ts_ip=$(container_exec 'tailscale ip -4')
            log_info "Tailscale already connected: $ts_ip"
            return 0
        fi
        log_info "Tailscale installed but not connected, connecting..."
    else
        log_info "Installing Tailscale..."
        container_exec 'curl -fsSL https://tailscale.com/install.sh | sh'
    fi

    # Connect with authkey
    log_info "Connecting to Tailscale..."
    container_exec "tailscale up --authkey='$TAILSCALE_AUTHKEY'"

    # Wait for connection with timeout (60s per CONTEXT.md)
    wait_for_tailscale
}
```

**Connection wait function:**
```bash
wait_for_tailscale() {
    local timeout=60
    local elapsed=0
    local spinstr='|/-\'

    echo -n "  Waiting for Tailscale connection..."

    while [[ $elapsed -lt $timeout ]]; do
        if container_exec 'tailscale status 2>/dev/null | grep -q "^100\\."'; then
            printf "\r\033[K"
            local ts_ip
            ts_ip=$(container_exec 'tailscale ip -4')
            log_info "Tailscale connected: $ts_ip"
            return 0
        fi

        local temp=${spinstr#?}
        printf "\r  [%c] Waiting for Tailscale... (%ds/%ds)" "$spinstr" "$elapsed" "$timeout"
        spinstr=$temp${spinstr%"$temp"}

        sleep 1
        ((elapsed++))
    done

    printf "\r\033[K"
    log_error "Tailscale connection timed out after ${timeout}s"
    echo "Container left running for debugging (per CONTEXT.md):"
    echo "  lxc exec $CONTAINER_NAME -- tailscale status"
    echo "  lxc exec $CONTAINER_NAME -- journalctl -u tailscaled"
    return 1
}
```

**Key patterns from research:**
- Use `tailscale up --authkey=` (not --auth-key)
- Check for "^100\\." pattern in status output
- Get IP with `tailscale ip -4`
- Leave container running on failure for debugging
  </action>
  <verify>Function exists and has proper error handling: `grep -A5 "install_tailscale" 03-provision-container.sh`</verify>
  <done>Tailscale install function with idempotency check, authkey connection, and 60s timeout implemented</done>
</task>

<task type="auto">
  <name>Task 3: Implement PostgreSQL installation and configuration (PROV-07, PROV-08)</name>
  <files>03-provision-container.sh</files>
  <action>
Add PostgreSQL installation function.

**Installation with idempotency:**
```bash
install_postgresql() {
    log_info "Setting up PostgreSQL..."

    # Check if already installed
    if container_exec 'dpkg-query -W -f="\${Status}" postgresql 2>/dev/null | grep -q "install ok installed"'; then
        log_info "PostgreSQL already installed"

        # Verify user/db exist
        if container_exec "sudo -u postgres psql -tAc \"SELECT 1 FROM pg_roles WHERE rolname='$PG_USER'\" | grep -q 1"; then
            log_info "PostgreSQL user '$PG_USER' exists"
        else
            create_pg_user_db
        fi
        return 0
    fi

    wait_for_apt_lock

    log_info "Installing PostgreSQL..."
    container_exec '
        DEBIAN_FRONTEND=noninteractive apt-get install -y -qq \
            postgresql \
            postgresql-contrib
    '

    # Wait for PostgreSQL to start
    container_exec 'systemctl enable postgresql && systemctl start postgresql'
    sleep 2

    create_pg_user_db
    configure_pg_remote_access
}
```

**User and database creation:**
```bash
create_pg_user_db() {
    log_info "Creating PostgreSQL user and database..."

    # Create user if not exists
    container_exec "sudo -u postgres psql -tAc \"SELECT 1 FROM pg_roles WHERE rolname='$PG_USER'\" | grep -q 1 || sudo -u postgres createuser $PG_USER"

    # Set password
    container_exec "sudo -u postgres psql -c \"ALTER USER $PG_USER WITH PASSWORD '$PG_PASS';\""

    # Create database if not exists
    container_exec "sudo -u postgres psql -tAc \"SELECT 1 FROM pg_database WHERE datname='$PG_DB'\" | grep -q 1 || sudo -u postgres createdb -O $PG_USER $PG_DB"

    # Install pgcrypto extension (per RESEARCH.md recommendation)
    container_exec "sudo -u postgres psql -d $PG_DB -c 'CREATE EXTENSION IF NOT EXISTS pgcrypto;'"

    log_info "PostgreSQL user '$PG_USER', database '$PG_DB' ready"
}
```

**Remote access configuration:**
```bash
configure_pg_remote_access() {
    log_info "Configuring PostgreSQL for remote access..."

    container_exec '
        # Find PostgreSQL version directory
        PG_VERSION=$(ls /etc/postgresql/)
        PG_CONF="/etc/postgresql/$PG_VERSION/main/postgresql.conf"
        PG_HBA="/etc/postgresql/$PG_VERSION/main/pg_hba.conf"

        # Listen on all interfaces (for Tailscale access)
        sed -i "s/#listen_addresses = '"'"'localhost'"'"'/listen_addresses = '"'"'*'"'"'/" "$PG_CONF"

        # Check if trust rules already exist
        if ! grep -q "host.*all.*all.*0.0.0.0/0.*trust" "$PG_HBA"; then
            # Add trust authentication for all connections (dev only!)
            echo "# Allow all connections with trust (dev environment)" >> "$PG_HBA"
            echo "host    all    all    0.0.0.0/0    trust" >> "$PG_HBA"
            echo "host    all    all    ::0/0        trust" >> "$PG_HBA"
        fi

        # Restart PostgreSQL to apply changes
        systemctl restart postgresql
    '

    log_info "PostgreSQL configured for remote access"
}
```

**Key patterns from research:**
- Use dpkg-query for idempotent package check
- Use createuser/createdb commands (not raw SQL)
- listen_addresses = '*' for Tailscale access
- trust auth for dev environment
- Install pgcrypto extension
  </action>
  <verify>PostgreSQL functions exist: `grep -c "install_postgresql\|create_pg_user_db\|configure_pg_remote_access" 03-provision-container.sh` should return 3+</verify>
  <done>PostgreSQL installation with user/db creation, pgcrypto extension, and remote access configured</done>
</task>

<task type="auto">
  <name>Task 4: Implement nvm, Node.js, and package managers (PROV-05, PROV-06)</name>
  <files>03-provision-container.sh</files>
  <action>
Add nvm/Node.js installation function.

**Important from research:** nvm must be sourced explicitly in non-interactive shells.

```bash
install_node() {
    log_info "Setting up Node.js environment..."

    # Check if nvm already installed
    if container_exec '[ -s "$HOME/.nvm/nvm.sh" ]'; then
        log_info "nvm already installed"
    else
        log_info "Installing nvm $NVM_VERSION..."
        container_exec "curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/$NVM_VERSION/install.sh | bash"
    fi

    # Source nvm and check/install Node.js
    # CRITICAL: Must source nvm.sh for non-interactive shell
    container_exec '
        export NVM_DIR="$HOME/.nvm"
        [ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"

        if nvm ls '"$NODE_VERSION"' &>/dev/null; then
            echo "Node.js '"$NODE_VERSION"' already installed"
        else
            echo "Installing Node.js '"$NODE_VERSION"'..."
            nvm install '"$NODE_VERSION"'
        fi

        nvm alias default '"$NODE_VERSION"'
        nvm use default
    '

    # Verify installation
    local node_version
    node_version=$(container_exec '
        export NVM_DIR="$HOME/.nvm"
        [ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"
        node --version
    ')
    log_info "Node.js installed: $node_version"

    # Enable corepack for yarn and pnpm
    log_info "Enabling corepack for yarn and pnpm..."
    container_exec '
        export NVM_DIR="$HOME/.nvm"
        [ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"
        corepack enable
    '

    # Verify package managers
    local npm_ver yarn_ver pnpm_ver
    npm_ver=$(container_exec '
        export NVM_DIR="$HOME/.nvm"
        [ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"
        npm --version
    ')
    yarn_ver=$(container_exec '
        export NVM_DIR="$HOME/.nvm"
        [ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"
        yarn --version
    ')
    pnpm_ver=$(container_exec '
        export NVM_DIR="$HOME/.nvm"
        [ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"
        pnpm --version
    ')

    log_info "Package managers: npm $npm_ver, yarn $yarn_ver, pnpm $pnpm_ver"
}
```

**Key patterns from research:**
- Always source nvm.sh before using nvm commands
- Use corepack enable (built into Node.js) for yarn/pnpm
- Don't install yarn/pnpm manually
  </action>
  <verify>Function sources nvm correctly: `grep -A20 "install_node" 03-provision-container.sh | grep "NVM_DIR"` should show sourcing pattern</verify>
  <done>nvm, Node.js 22, and corepack-managed yarn/pnpm installed with proper shell sourcing</done>
</task>

<task type="auto">
  <name>Task 5: Implement Playwright and Claude Code installation (PROV-09, PROV-10)</name>
  <files>03-provision-container.sh</files>
  <action>
Add Playwright and Claude Code installation functions.

**Playwright installation:**
```bash
install_playwright() {
    log_info "Setting up Playwright..."

    # Check if Playwright browsers already installed
    if container_exec '[ -d "$HOME/.cache/ms-playwright" ]'; then
        log_info "Playwright browsers already installed"
        return 0
    fi

    log_info "Installing Playwright with Chromium and Firefox..."
    # --with-deps installs system dependencies automatically
    container_exec '
        export NVM_DIR="$HOME/.nvm"
        [ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"
        npx playwright install --with-deps chromium firefox
    '

    log_info "Playwright browsers installed"
}
```

**Claude Code installation:**
```bash
install_claude_code() {
    log_info "Setting up Claude Code..."

    # Check if already installed
    if container_exec 'command -v claude &>/dev/null || [ -f "$HOME/.local/bin/claude" ]'; then
        local claude_ver
        claude_ver=$(container_exec '$HOME/.local/bin/claude --version 2>/dev/null || claude --version 2>/dev/null' || echo "installed")
        log_info "Claude Code already installed: $claude_ver"
        return 0
    fi

    log_info "Installing Claude Code CLI..."
    # Use native installer per RESEARCH.md recommendation (not npm)
    container_exec 'curl -fsSL https://claude.ai/install.sh | bash'

    # Verify installation
    if container_exec '[ -f "$HOME/.local/bin/claude" ]'; then
        log_info "Claude Code installed at ~/.local/bin/claude"
    else
        log_warn "Claude Code installation may have failed - check manually"
    fi
}
```

**Key patterns from research:**
- Use `npx playwright install --with-deps` (not manual browser download)
- Only install chromium and firefox (per CONTEXT.md)
- Use native installer for Claude Code (not npm global)
- Claude installs to ~/.local/bin/claude
  </action>
  <verify>Both functions exist: `grep -c "install_playwright\|install_claude_code" 03-provision-container.sh` should return 2+</verify>
  <done>Playwright with Chromium/Firefox and Claude Code CLI installed with idempotency checks</done>
</task>

<task type="auto">
  <name>Task 6: Implement shell configuration and final verification (PROV-11)</name>
  <files>03-provision-container.sh</files>
  <action>
Add shell configuration and main execution with verification.

**Shell configuration function:**
```bash
configure_shell() {
    log_info "Configuring shell environment..."

    # Get Tailscale IP for use in env vars
    local ts_ip
    ts_ip=$(container_exec 'tailscale ip -4' 2>/dev/null || echo "not-connected")

    # Add to .bashrc if not already present
    container_exec '
        BASHRC="$HOME/.bashrc"
        MARKER="# Dev Sandbox Environment"

        if grep -q "$MARKER" "$BASHRC"; then
            echo "Shell already configured"
        else
            cat >> "$BASHRC" << '"'"'SHELL_CONFIG'"'"'

# Dev Sandbox Environment
# Added by 03-provision-container.sh

# Database environment variables
export PGHOST=localhost
export PGPORT=5432
export PGUSER=dev
export PGPASSWORD=dev
export PGDATABASE=dev
export DATABASE_URL="postgresql://dev:dev@localhost:5432/dev"

# Node.js via nvm (auto-load)
export NVM_DIR="$HOME/.nvm"
[ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"
[ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion"

# Claude Code
export PATH="$HOME/.local/bin:$PATH"

# Useful aliases
alias ll="ls -la"
alias pg="psql -U dev dev"
alias pgstart="sudo systemctl start postgresql"
alias pgstop="sudo systemctl stop postgresql"
alias pgstatus="sudo systemctl status postgresql"
alias tsstatus="tailscale status"
alias tsip="tailscale ip -4"

# Dev helper aliases
alias npmi="npm install"
alias npmr="npm run"
alias pnpmi="pnpm install"
alias yarni="yarn install"

SHELL_CONFIG
        fi
    '

    log_info "Shell environment configured"
}
```

**Main execution block:**
```bash
# ============================================
# MAIN SCRIPT
# ============================================

echo "=========================================="
echo "Dev Sandbox - Stack Provisioning"
echo "=========================================="
echo ""

# Argument validation already done above, now execute steps

log_info "Provisioning container: $CONTAINER_NAME"
echo ""

# Install components in dependency order (per RESEARCH.md)
install_tailscale      # First - provides connectivity verification
install_postgresql     # Early - apt-based, stable
install_node           # After apt, provides npm
install_playwright     # Requires npm
install_claude_code    # Last - independent
configure_shell        # After all tools installed

# Final verification and status summary
print_status_summary
```

**Status summary function:**
```bash
print_status_summary() {
    echo ""
    echo "=========================================="
    echo "Provisioning Complete!"
    echo "=========================================="
    echo ""

    # Gather all version info
    local ts_ip node_ver npm_ver yarn_ver pnpm_ver pg_ver claude_ver

    ts_ip=$(container_exec 'tailscale ip -4' 2>/dev/null || echo "not connected")

    node_ver=$(container_exec '
        export NVM_DIR="$HOME/.nvm"
        [ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"
        node --version
    ' 2>/dev/null || echo "not installed")

    npm_ver=$(container_exec '
        export NVM_DIR="$HOME/.nvm"
        [ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"
        npm --version
    ' 2>/dev/null || echo "not installed")

    yarn_ver=$(container_exec '
        export NVM_DIR="$HOME/.nvm"
        [ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"
        yarn --version
    ' 2>/dev/null || echo "not installed")

    pnpm_ver=$(container_exec '
        export NVM_DIR="$HOME/.nvm"
        [ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"
        pnpm --version
    ' 2>/dev/null || echo "not installed")

    pg_ver=$(container_exec 'psql --version' 2>/dev/null | head -1 || echo "not installed")

    claude_ver=$(container_exec '$HOME/.local/bin/claude --version' 2>/dev/null || echo "not installed")

    echo "Container: $CONTAINER_NAME"
    echo ""
    echo "Tailscale:"
    echo "  IP: $ts_ip"
    echo "  Status: $(container_exec 'tailscale status --self' 2>/dev/null | head -1 || echo 'unknown')"
    echo ""
    echo "Node.js:"
    echo "  Node: $node_ver"
    echo "  npm: $npm_ver"
    echo "  yarn: $yarn_ver"
    echo "  pnpm: $pnpm_ver"
    echo ""
    echo "PostgreSQL:"
    echo "  Version: $pg_ver"
    echo "  User: $PG_USER"
    echo "  Database: $PG_DB"
    echo "  Listen: 0.0.0.0:5432 (accessible via Tailscale)"
    echo ""
    echo "Playwright:"
    echo "  Browsers: Chromium, Firefox"
    echo ""
    echo "Claude Code:"
    echo "  Version: $claude_ver"
    echo "  Path: ~/.local/bin/claude"
    echo ""
    echo "=========================================="
    echo "Connection Instructions"
    echo "=========================================="
    echo ""
    echo "SSH (from any Tailscale device):"
    echo "  ssh root@$ts_ip"
    echo "  ssh $CONTAINER_NAME  # if MagicDNS enabled"
    echo ""
    echo "PostgreSQL (from dev machine):"
    echo "  psql -h $ts_ip -U dev dev"
    echo "  # or with DATABASE_URL:"
    echo "  postgresql://dev:dev@$ts_ip:5432/dev"
    echo ""
    echo "Inside container:"
    echo "  lxc exec $CONTAINER_NAME -- bash"
    echo ""
}
```

Make script executable is handled by Task 1's header (#!/bin/bash).
  </action>
  <verify>Script has all main components: `grep -c "install_tailscale\|install_postgresql\|install_node\|install_playwright\|install_claude_code\|configure_shell\|print_status_summary" 03-provision-container.sh` should return 7+</verify>
  <done>Shell configured with database env vars, aliases, and comprehensive status summary with connection instructions</done>
</task>

</tasks>

<verification>
After all tasks complete, verify:

1. **Syntax check:**
   ```bash
   bash -n 03-provision-container.sh && echo "Syntax OK"
   ```

2. **Script structure:**
   ```bash
   # Should have all major functions
   grep -E "^(install_|configure_|wait_for_|print_)" 03-provision-container.sh
   ```

3. **Idempotency patterns present:**
   ```bash
   # Should have multiple idempotency checks
   grep -c "already installed\|already configured\|already exists" 03-provision-container.sh
   ```

4. **Key configuration values:**
   ```bash
   grep -E "(listen_addresses|trust|NVM_DIR|--authkey|--with-deps)" 03-provision-container.sh
   ```

5. **Script line count (expect 400+ lines):**
   ```bash
   wc -l 03-provision-container.sh
   ```
</verification>

<success_criteria>
Phase 3 provisioning script is complete when:
- [ ] Script accepts container name and Tailscale auth key (PROV-01)
- [ ] Tailscale installation with idempotency check (PROV-02)
- [ ] Tailscale connection with authkey and 60s timeout (PROV-03)
- [ ] Tailscale IP verification (PROV-04)
- [ ] nvm and Node.js 22 installed (PROV-05)
- [ ] npm, yarn, pnpm available via corepack (PROV-06)
- [ ] PostgreSQL installed (PROV-07)
- [ ] dev/dev user/database created with pgcrypto (PROV-08)
- [ ] Playwright with Chromium and Firefox (PROV-09)
- [ ] Claude Code CLI installed (PROV-10)
- [ ] Shell has database env vars and aliases (PROV-11)
- [ ] Script is fully idempotent (safe to re-run)
- [ ] Final status summary shows all versions and connection info
- [ ] Script follows patterns from 01/02 scripts (colors, logging, error handling)
</success_criteria>

<output>
After completion, create `.planning/phases/03-stack-provisioning/03-01-SUMMARY.md`
</output>
